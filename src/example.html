<!DOCTYPE html>

<html lang="en">

<head>

    <title>WebVRFeatureDetector - Load Polyfills</title>

    <meta charset="utf-8">

    <!--favicon-->

    <link rel="icon" href="favicon.ico">

    <!--handle iOS and android mobile http://www.html5rocks.com/en/mobile/fullscreen/ ios fullscreen-->

    <meta name="apple-mobile-web-app-capable" content="yes">

    <!--android fullscreen-->

    <meta name="mobile-web-app-capable" content="yes">

    <!--set the viewport, shrink-to-fit fixes safari bug-->

    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.01, minimal-ui">

    <!--hide the Apple status bar for iOS-->

    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <!--CSS files-->

    <link rel="stylesheet" href="css/styles.css">

    <!--load the WebVRFeatureDetector which does a suite of (non-Promise) detections-->

    <script src="js/webvr-feature-detector.js"></script>

    <!--handle ancient web browsers that don't support HTML5 or HTML5 canvas with a shiv Document.write() is used for extreme back-compatibility-->

    <script>

        if ( WebVRFeatureDetector ) {

            if ( !WebVRFeatureDetector.html5 ) {

                document.write( '<script src="' + 'js/polyfills/html5shiv.min.js' + '" type="text/javascript"><\/script>' );

            }

        }

    </script>

    <!--load ui methods directly-->

    <script src='js/webvr-dom-ui.js'></script>

    </head>

<body>

    <!--canvas is dynamically created and fills body-->

<script>

// webvr-polyfill configuration, only used if native API not available

var WebVRConfig = {

    /* 
     * ==============================================
     * Prevent the polyfill from initializing immediately. Requires the app
     * to call InitializeWebVRPolyfill() before it can be used.
     * ==============================================
     */
    DEFER_INITIALIZATION: false, // Default: false

    // Enable the deprecated version of the API (navigator.getVRDevices)

    ENABLE_DEPRECATED_API: false, // Default: false

    FORCE_ENABLE_VR: true,

    /* 
     * To disable keyboard and mouse controls, if you want to use your own
     * implementation
     */
    MOUSE_KEYBOARD_CONTROLS_DISABLED: true, // Default: false

    BUFFER_SCALE: 1.0, // Default: 1.0. // Default: false < 1 for faster performance

    /* 
     * ==============================================
     * Allow VRDisplay.submitFrame to change gl bindings, which is more
     * efficient if the application code will re-bind its resources on the
     * next frame anyway. This has been seen to cause rendering glitches with THREE.js.
     * Dirty bindings include: gl.FRAMEBUFFER_BINDING, gl.CURRENT_PROGRAM,
     * gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING,
     * and gl.TEXTURE_BINDING_2D for texture unit 0.
     * ==============================================
     */
    DIRTY_SUBMIT_FRAME_BINDINGS: true // Default: false.

};


/**
 * ==============================================
 * 1. Eliminate browsers that can't possibly run the vr world.
 * 2. Flag browsers that pass the tests, 
 * but crash on this world (e.g. Google Chrome 9, which 
 * freezes when you try to get a WebGL context).
 * 
 * If the <canvas> already exists, .browserFail() will replace 
 * it with a supplied warning image.
 * 
 * If there is no <canvas> yet, supply .browserFail() with a parent 
 * DOM element where the warning image may be attached.
 * ==============================================
 */

    // the image to display when we can't load HTML5 <canvas>

    var failImg = 'img/icons/no-vr.gif';

    var failClass = 'fail-message';

    if ( typeof WebVRFeatureDetector === undefined || ! WebVRFeatureDetector.canvas || 
        ! WebVRFeatureDetector.addEventListener ) {

        domui.browserFail( 'Your browser is too old to support 3d or VR (upgrade).', failImg, failClass, document.body );

        //alert( 'Your browser does not support this page (upgrade).' );

    } else if ( WebVRFeatureDetector.browser.ie && WebVRFeatureDetector.browser.ie < 11 ) {

        domui.browserFail( 'Old versions of Internet Explorer do not support THREE.js, WebVR cannot run.', failImg, failClass, document.body );

    } else if (WebVRFeatureDetector.browser.firefox && WebVRFeatureDetector.browser.firefox < 15) {

        domui.browserFail( 'Old versions of Firefox do not support THREE.js, WebVR cannot run.', failImg, failClass, document.body );

    } else if (WebVRFeatureDetector.browser.chrome && WebVRFeatureDetector.browser.chrome == 9) {

        domui.browserFail('This version of Chrome does not support THREE.js, WebVR cannot run.', failImg, failClass, document.body );

    } else {

        // don't want touchmove in VR

        document.addEventListener( 'touchmove', function( e ) {

            e.preventDefault();

        } );

    /** 
     * ==============================================
     * Begin loading libraries using WebVRFeatureDetector 
     * load() function. Loaded in sequential batches, 
     * with polyfill yes/no designation also supplied.
     * ==============================================
     */

    console.log ('loading libraries...');

     // start <progress> dialog (updated in callbacks from WebVRFeatureDetector.load() )

     var progElem = domui.createProgress( 'dom-ui-progress-container', 'dom-ui-progress', 0, 100 );

    // Load all libraries and polyfills required for WebGL VR and fullscreen rendering

    WebVRFeatureDetector.load([
      [
        {name: 'addEventListener', path: 'js/polyfills/ie8.js', poly: true},
        {name: 'querySelectorAll', path: 'js/polyfills/dom.js', poly: true}
      ],
      [
        {name: 'defineProperty', path: 'js/polyfills/es5.js', poly: true},
        {name: 'typedArray', path: 'js/polyfills/typedarray.js', poly: true},
        {name: 'promise', path: 'js/polyfills/promise.min.js', poly: true}
      ],
      [
        {name: 'WebVRPolyfill', path: 'js/polyfills/webvr-polyfill.js', poly: true}
      ],
      [
        {name: 'CustomEvent', path: 'js/polyfills/custom-event-polyfill.js', poly: true},
        {name: 'three', path: 'js/three/three.min.js', poly: false}
      ],
      [
        {name: 'projector', path: 'js/three/Projector.js', poly: false},
        {name: 'canvasRenderer', path: 'js/three/CanvasRenderer.js', poly: false},
        {name: 'OrbitControls', path: 'js/three/OrbitControls.js', poly: false},
        {name: 'VREffect', path: 'js/three/VREffect.js', poly: false},
        {name: 'VRControls', path: 'js/three/VRControls.js', poly: false}
      ],
      [
        {name: 'fetch', path: 'js/polyfills/fetch.js', poly: true},
        {name: 'ui', path: 'js/plutonian.js', poly: false}
      ]
    ], function() { // Main callback function

        // begin building the world

        if ( ! plutonian ) {

            console.error( 'Main error: plutonian.js is not defined.' );

            return;

        }

        // window width and height

        var w = window.innerWidth;

        var h = window.innerHeight;

        // Use device device pixel ratio

        if ( window.devicePixelRatio !== undefined ) {

            dpr = window.devicePixelRatio;

        } else {

            dpr = 1;

        }

        // Use WebGL, but fall back to <canvas> render for just one static scene if necessary

        if( WebVRFeatureDetector.webGL ) { // 3D scenes ok.

                renderer = new THREE.WebGLRenderer( {

                antialias: true //slow

                //,canvas: canvas

            } );

        } else { // Can't do 3d, draw the scene once and use as a fallback image.

            console.warn( 'Main warning: no webGL, fallback to still image snapshot' );

                renderer = new THREE.CanvasRenderer( {

                antialias: true

                //,canvas: canvas

            } );

        }

        // Additional renderer properties

        renderer.setViewport( 0, 0, w, h );

        renderer.setClearColor( 0x101010 );

        renderer.setPixelRatio( dpr );

        renderer.setSize( w, h );

        renderer.sortObjects = false;

        // Add the <canvas> to the browser <body> (document.body)

        document.body.appendChild( renderer.domElement );

        // Create the Scene

        var scene = new THREE.Scene();

        // Create the Camera

        var camera = new THREE.PerspectiveCamera(70, w / h, 0.1, 10000);

        camera.position.z = 0.0001;

        // Create a dolly for moving the VR head-tracking camera

        var dolly = new THREE.PerspectiveCamera();

        dolly.position.x = 0;

        dolly.position.y = 2;

        dolly.position.z = -8;

        dolly.add( camera );

        //dolly.rotation.x = Math.PI / 2;
        //dolly.rotation.y = Math.PI / 2.3; //firefox native webvr
        //dolly.rotation.z = Math.PI / 2;

        // Non-VR controls

        var controls = new THREE.OrbitControls( dolly, renderer.domElement ); // WORKS

        // Get the VRDisplay and save it for later

        var vrDisplay = null;

        navigator.getVRDisplays().then( function( displays ) {


            if ( displays.length > 0 ) {

                alert("setting display")
                vrDisplay = displays[0];

            }

        } );

        // Set up VR camera controls for head and position tracking.

        var vrControls = new THREE.VRControls( camera, function( err ) {

            if (err) {

                console.log( 'Main error: failed to create VRControls: ', err);

            }

        } );

        // Apply VR stereo rendering vrEffect to renderer

        var vrEffect = new THREE.VREffect( renderer, function( err ) {

            if ( err ) {

                console.log('Main error: failed to create VREffect: ', err);

            }

        } );

        vrEffect.setSize( w, h );

        /* 
         * World updates and events 
         */

        // TODO: Need polling here for Texture, Model, WebVR PolyfilL DPI files.

        // Build the Ui

        // Event listeners

        /** 
         * Listen for mouseDown
         * @param {Event} e the event
         */
        function onMouseDown ( e ) {

        };

        /** 
         * Listen for mouseUp
         * @param {Event} e the event
         */
        function onMouseUp ( e ) {

        };

        /** 
         * Listen for keyDown
         * @param {Event} e the event
         */
        function onKeydown ( e ) {

        };

        /** 
         * Listen for window Resizing
         * @param {Event} e the event
         */
        function onWindowResize ( e ) {

            w = window.innerWidth;

            h = window.innerHeight;

            console.log( 'Main: Resizing to %s x %s.', w, h );

            vrEffect.setSize( w, h );

            camera.aspect = w / h ;

            camera.updateProjectionMatrix();

        };

        /** 
         * Listen for a fullScreen change
         * @param {Event} e the event
         */
        function onFullscreenChange ( e ) {

        };

        /** 
         * Listen for an orientation change
         * @param {Event} e the event
         */
        function onOrientationChange ( e ) {

        };

        // VR specific events

        function onVRDisplayPresentChange ( e ) {

              onWindowResize();

        };

        function onVRDisplayDeviceParamsChange ( e ) {

        };


        /**
         * Add event listeners.
         */
        function addListeners () {

            // Add mouse events

            renderer.domElement.addEventListener( 'mousedown', onMouseDown, false );

            renderer.domElement.addEventListener( 'mouseup', onMouseUp, false );

            renderer.domElement.addEventListener( 'touchstart', onMouseDown, false );

            renderer.domElement.addEventListener( 'touchend', onMouseUp, false );

            // Escape key

            document.addEventListener( 'keydown', onKeydown, false );

            // Add resize events

            window.addEventListener( 'resize', onWindowResize, false );

            // Detect fullscreen API changes

            document.addEventListener( 'webkitfullscreenchange', onFullscreenChange, false );

            document.addEventListener( 'mozfullscreenchange', onFullscreenChange, false );

            document.addEventListener( 'fullscreenchange', onFullscreenChange, false );

            document.addEventListener( 'MSFullscreenChange', onFullscreenChange, false );

            // Listen for orientation changes on mobiles

            window.addEventListener( 'orientationchange', onOrientationChange, false );

            // Bind to VR* specific events

            window.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange );

            window.addEventListener( 'vrdisplaydeviceparamschange', onVRDisplayDeviceParamsChange );

        };

        // Starting time, used by THREE controls

        var clock = new THREE.Clock();

        // Rendering loop

        function render () {

            var delta = clock.getDelta(); // needed for composer (postprocessing image)

            if ( isVR ) {
                console.log('vr') ///////////////////////

                vrControls.update();

                vrEffect.render( scene, camera );

            }  else {
                console.log('fs') ///////////////////////

                controls.update( delta );

                renderer.render( scene, camera );

            }

        };

        function animate () {

            plutonian.update();

            render();

            requestAnimationFrame( animate );

        };

        // Starting time

        function start () {

            // Enter the rendering loop, using either WebGL or <canvas> renderer

            if ( WebVRFeatureDetector.canvas ) {

                if ( WebVRFeatureDetector.webGL ) {

                    addListeners();

                    animate();

                } else {

                    // WebGL not supported, so just draw one frame and end

                    WebVRUi.setMessage('WebVR cannnot run (No 3D support, static frame shown)', false);

                    render();

                }

            }

        }

        /* 
         * Flags for VR and fullscreen
         */
        var isVR = false, isFullscreen = false;

        /* 
         * Set up the button Ui, overlay on the <canvas> element
         */
        domui.createControlPanel( 'Plutonian', 
            'dom-ui-control-panel', 
            'dom-ui-text', 
            'dom-ui-buttons', 
            'dom-ui-links');

        //TODO: vrDisplay is NULL when created, attach in callback and activate button
        //TODO:
        //TODO:

        domui.addControlButton( 'fullscreen', function () {

            isFullscreen = true;

            isVR = false;

            domui.enterFullscreen( renderer.domElement );

        } );

            window.disp = vrDisplay;
            window.cc = renderer.domElement;

        domui.addControlButton( 'VR', function () {

            isVR = true;

            isFullscreen = false;

            alert('setting display:' + vrDisplay)

            vrDisplay.requestPresent( [ { source: renderer.domElement } ] );

        } );

        domui.addControlLink( 'home');

        /* 
         * Create the virtual world simulation, loading models and textures. 
         * When it is complete, start the animation.
         */
        plutonian.init( scene, camera, renderer, dolly, start);


        // End of load and render VR world

    }, function( percent, msg ) { // Callback - Progress Bar values from WebVRFeatureDetector

        if ( percent >= 100 ) {

            domui.updateProgress( progElem, percent, msg );

            domui.finishProgress( progElem );

        } else {

            // this updates and completes BEFORE texture loading.

            domui.updateProgress( progElem, percent, msg );
        }

    }, function( msg, batch, script, s ) { // Callback - error in WebVRFeatureDetector

        console.error( msg  + ' batch#' + batch + ', script#' + script + ', value:' + s );

        domui.hideProgress( progElem );

    } );


    } // end of valid browser test


    </script>
  </body>
</html>
