<!DOCTYPE html>

<html lang="en">

<head>

    <title>WebVRFeatureDetector - Load Polyfills</title>

    <meta charset="utf-8">

    <!--favicon-->

    <link rel="icon" href="favicon.ico">

    <!--handle iOS and android mobile http://www.html5rocks.com/en/mobile/fullscreen/ ios fullscreen-->

    <meta name="apple-mobile-web-app-capable" content="yes">

    <!--android fullscreen-->

    <meta name="mobile-web-app-capable" content="yes">

    <!--set the viewport, shrink-to-fit fixes safari bug-->

    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.01, minimal-ui">

    <!--hide the Apple status bar for iOS-->

    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <!--CSS files-->

    <link rel="stylesheet" href="css/styles.css">

    <!--load the WebVRFeatureDetector which does a suite of (non-Promise) detections-->

    <script src="js/webvr-feature-detector.js"></script>

    <!--handle ancient web browsers that don't support HTML5 or HTML5 canvas with a shiv Document.write() is used for extreme back-compatibility-->

    <script>

        if ( WebVRFeatureDetector ) {

            if ( !WebVRFeatureDetector.html5 ) {

                document.write( '<script src="' + 'js/polyfills/html5shiv.min.js' + '" type="text/javascript"><\/script>' );

            }

        }

    </script>

    <!--load ui methods directly-->

    <script src='js/webvr-dom-ui.js'></script>

    </head>

<body>

    <!--canvas is dynamically created-->

<script>

// webvr-polyfill configuration, only used if native API not available

var WebVRConfig = {

    /* 
     * ==============================================
     * Prevent the polyfill from initializing immediately. Requires the app
     * to call InitializeWebVRPolyfill() before it can be used.
     * ==============================================
     */
    DEFER_INITIALIZATION: false, // Default: false

    // Enable the deprecated version of the API (navigator.getVRDevices)

    ENABLE_DEPRECATED_API: false, // Default: false

    FORCE_ENABLE_VR: true,

    /* 
     * To disable keyboard and mouse controls, if you want to use your own
     * implementation
     */
    MOUSE_KEYBOARD_CONTROLS_DISABLED: true, // Default: false

    BUFFER_SCALE: 1.0, // Default: 1.0. // Default: false < 1 for faster performance

    /* 
     * ==============================================
     * Allow VRDisplay.submitFrame to change gl bindings, which is more
     * efficient if the application code will re-bind its resources on the
     * next frame anyway. This has been seen to cause rendering glitches with THREE.js.
     * Dirty bindings include: gl.FRAMEBUFFER_BINDING, gl.CURRENT_PROGRAM,
     * gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING,
     * and gl.TEXTURE_BINDING_2D for texture unit 0.
     * ==============================================
     */
    DIRTY_SUBMIT_FRAME_BINDINGS: true // Default: false.

};


/**
 * ==============================================
 * 1. Eliminate browsers that can't possibly run the vr world.
 * 2. Flag browsers that pass the tests, 
 * but crash on this world (e.g. Google Chrome 9, which 
 * freezes when you try to get a WebGL context).
 * 
 * If the <canvas> already exists, .browserFail() will replace 
 * it with a supplied warning image.
 * 
 * If there is no <canvas> yet, supply .browserFail() with a parent 
 * DOM element where the warning image may be attached.
 * ==============================================
 */

    // the image to display when we can't load HTML5 <canvas>

    var failImg = 'img/icons/no-vr.gif';

    var failClass = 'fail-message';

    if ( typeof WebVRFeatureDetector === undefined || ! WebVRFeatureDetector.canvas || 
        ! WebVRFeatureDetector.addEventListener ) {

        domui.browserFail( 'Your browser is too old to support 3d or VR (upgrade).', failImg, failClass, document.body );

        //alert( 'Your browser does not support this page (upgrade).' );

    } else if ( WebVRFeatureDetector.browser.ie && WebVRFeatureDetector.browser.ie < 11 ) {

        domui.browserFail( 'Old versions of Internet Explorer do not support THREE.js, WebVR cannot run.', failImg, failClass, document.body );

    } else if (WebVRFeatureDetector.browser.firefox && WebVRFeatureDetector.browser.firefox < 15) {

        domui.browserFail( 'Old versions of Firefox do not support THREE.js, WebVR cannot run.', failImg, failClass, document.body );

    } else if (WebVRFeatureDetector.browser.chrome && WebVRFeatureDetector.browser.chrome == 9) {

        domui.browserFail('This version of Chrome does not support THREE.js, WebVR cannot run.', failImg, failClass, document.body );

    } else {

        // don't want touchmove in VR

        document.addEventListener( 'touchmove', function( e ) {

            e.preventDefault();

        });

    /** 
     * ==============================================
     * Begin loading libraries using WebVRFeatureDetector 
     * load() function. Loaded in sequential batches, 
     * with polyfill yes/no designation also supplied.
     * ==============================================
     */

     console.log ('loading world...');

     // start <progress> dialog

     var progress = domui.createProgress( 'domui-progress-container', 'domui-progress', 0, 100 );

    // Load all scripts required for the virtual world.
    WebVRFeatureDetector.load([
      [
        {name: 'addEventListener', path: 'js/polyfills/ie8.js', poly: true},
        {name: 'querySelectorAll', path: 'js/polyfills/dom.js', poly: true}
      ],
      [
        {name: 'defineProperty', path: 'js/polyfills/es5.js', poly: true},
        {name: 'typedArray', path: 'js/polyfills/typedarray.js', poly: true},
        {name: 'promise', path: 'js/polyfills/promise.min.js', poly: true}
      ],
      [
        {name: 'WebVRPolyfill', path: 'js/polyfills/webvr-polyfill.js', poly: true}
      ],
      [
        {name: 'CustomEvent', path: 'js/polyfills/custom-event-polyfill.js', poly: true},
        {name: 'three', path: 'js/three/three.min.js', poly: false}
      ],
      [
        {name: 'projector', path: 'js/three/Projector.js', poly: false},
        {name: 'canvasRenderer', path: 'js/three/CanvasRenderer.js', poly: false},
        {name: 'OrbitControls', path: 'js/three/OrbitControls.js', poly: false},
        {name: 'VREffect', path: 'js/three/VREffect.js', poly: false},
        {name: 'VRControls', path: 'js/three/VRControls.js', poly: false}
      ],
      [
        {name: 'fetch', path: 'js/polyfills/fetch.js', poly: true},
        {name: 'ui', path: 'js/plutonian.js', poly: false}
      ]
    ], function() { // Main callback function

        // begin building the world

        if ( ! plutonian ) {

            console.error( 'Main error: plutonian.js is not defined.' );

            return;

        }

        // window width and height

        var w = window.innerWidth;

        var h = window.innerHeight;

        // Use device device pixel ratio

        if ( window.devicePixelRatio !== undefined ) {

            dpr = window.devicePixelRatio;

        } else {

            dpr = 1;

        }

        // Use WebGL, but fall back to <canvas> render for just one static scene if necessary

        if( WebVRFeatureDetector.webGL ) { // 3D scenes ok.

                renderer = new THREE.WebGLRenderer({

                antialias: true, //slow

                //canvas: canvas

            });

        } else { // Can't do 3d, draw the scene once and use as a fallback image.

            console.warn( 'Main warning: no webGL, fallback to still image snapshot' );

                renderer = new THREE.CanvasRenderer({

                antialias: true,

                //canvas: canvas

            });

        }

        // Additional renderer properties

        renderer.setViewport( 0, 0, w, h );

        renderer.setClearColor( 0x101010 );

        renderer.setPixelRatio( dpr );

        renderer.setSize( w, h );

        renderer.sortObjects = false;

        // Create the Scene

        var scene = new THREE.Scene();

        // Create the Camera

        var camera = new THREE.PerspectiveCamera(70, w / h, 0.1, 10000);

        camera.position.z = 0.0001;

        // Create a dolly for moving the VR head-tracking camera

        var dolly = new THREE.PerspectiveCamera();

        dolly.position.x = 0;

        dolly.position.y = 2;

        dolly.position.z = -8;

        dolly.add( camera );

        //dolly.rotation.x = Math.PI / 2;
        //dolly.rotation.y = Math.PI / 2.3; //firefox native webvr
        //dolly.rotation.z = Math.PI / 2;

        // Non-VR controls

        var controls = new THREE.OrbitControls( dolly, renderer.domElement ); // WORKS

        // Set up VR camera controls for head and position tracking.

        var vrControls = new THREE.VRControls( camera, function( err ) {

            if (err) {

                console.log("Main error: failed to create VRControls: ", err);

            }

        });

        // Apply VR stereo rendering vrEffect to renderer

        var vrEffect = new THREE.VREffect( renderer, function( err ) {

            if ( err ) {

                console.log("Main error: failed to create VREffect: ", err);

            }

        });

        // Create the virtal world scene, using the renderer

        plutonian.init( scene, camera, renderer, dolly );

        // TODO: Need polling here for Texture, Model, WebVR PolyfilL DPI files.

        // Build the Ui

        // Event listeners

        function addListeners () {

        };

        // Rendering loop

        function animate () {

            requestAnimationFrame( animate );

            render();

        };

        function render () {

            var delta = clock.getDelta(); // needed for composer (postprocessing image)

            plutonian.update();

        };

        // Starting time

        var clock = new THREE.Clock();

        // Enter the rendering loop

        if ( WebVRFeatureDetector.canvas ) {
            if ( WebVRFeatureDetector.webGL ) {

                addListeners();

                animate();

            } else {

            // WebGL not supported, so just draw one frame and end

            WebVRUi.setMessage('WebVR cannnot run (No 3D support, static frame shown)', false);

            render();

            }

        }

        // End of load and render VR world

    }, function( percent, msg ) { // Callback - Progress Bar values from WebVRFeatureDetector

        // this updates and completes BEFORE texture loading.
        //console.log( 'progress function, ' + percent + '%' + ' for:' + msg );
        domui.updateProgress( progress, percent, msg );

    }, function( msg, batch, script, s ) { // Callback - error in WebVRFeatureDetector

        console.error( msg  + ' batch#' + batch + ', script#' + script + ', value:' + s );

        domui.hideProgress( progress );

    } );


    } // end of valid browser test


    </script>
  </body>
</html>
